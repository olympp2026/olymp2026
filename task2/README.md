# Задание 2. Смена сезонов (Photo1 ↔ Photo2)
## Кратко

Скрипт выполняет два преобразования:

- Photo1 (осень) -> Summer.jpg (лето): делает листву на осеннем фото более "летней" (зеленой) по цветовой статистике летнего изображения.

- Photo2 (лето) -> Autumn.jpg (осень): перекрашивает зеленую листву в осенние оттенки (оранжево-желтые), сохраняя яркость и избегая артефактов на стволах/небе.

#### Результат — два файла: Summer.jpg и Autumn.jpg.

## Используемые методы
### 1) Сегментация листвы по цвету (HSV)

Чтобы менять сезон только в области листвы, строится маска по цветовым порогам в пространстве HSV:

- Hue (H) — оттенок (зеленый/оранжевый и т.д.)

- Saturation (S) — насыщенность (серый ↔ "сочный" цвет)

- Value (V) — яркость

Для лета выбирается диапазон зеленых оттенков (примерно H≈35..95), для осени — теплые оттенки (H≈0..50).

### 2) Удаление "небоподобных" областей (bright + low saturation)

Белое небо/облака часто имеют низкую насыщенность и высокую яркость. Чтобы случайно не перекрашивать небо, из маски удаляются пиксели с (S < 35) & (V > 170).

### 3) Морфологическая постобработка масок (close/open)

После порогов маска может содержать шум и дырки. Поэтому применяется:

- CLOSE (закрытие) — заделывает дырки/разрывы

- OPEN (открытие) — удаляет мелкие "пятна"

### 4) Мягкие границы (feather / размытие маски)

Чтобы переходы выглядели естественно, бинарная маска переводится в альфу (0..1) с размытием. Это дает плавное смешивание на границах кроны.

### 5) Перенос цветовой статистики (Reinhard) в Lab (только a,b)

Для преобразования осень -> лето используется перенос статистики Reinhard color transfer в пространстве Lab.

Важно: изменяются только каналы a и b (цветность), яркость L не меняется. Это снижает артефакты "свечения" и сохраняет освещение сцены.

### 6) Прямое перекрашивание листвы (HSV) для лета -> осени

Для лето -> осень используется управляемое перекрашивание в HSV:

- задаем осенний hue_target (оранжевый ~ 15..25 в шкале OpenCV 0..179),

- усиливаем насыщенность (sat_boost),

- слегка понижаем яркость (val_scale) для более натурального "осеннего" вида.

### 7) Защита стволов/веток

Чтобы не перекрашивать стволы и ветки, альфа обнуляется на пикселях с низкой насыщенностью/яркостью:
```
trunk_like = (S < 80) | (V < 45).
```
### 8) Усиление маски в тенях (нижняя крона)

Нижняя часть кроны часто темнее, из-за чего не попадает в маску. Для этого:

- строится базовая маска,

- создается "добавочная" маска через dilate,

- фильтруется по (S >= 80) & (V >= 45) и объединяется с основной.


## Структура алгоритма и подробное описание шагов

Ниже описан полный пайплайн скрипта `swap.py` с указанием **какие операции выполняются**, **какие функции/инструменты используются** (из `opencv-python`/`numpy`) и **где вручную подбирались параметры**.

---

### Вход / выход

**Вход:**

* `Photo1.jpg` — осеннее фото (autumn)
* `Photo2.jpg` — летнее фото (summer)

**Выход:**

* `Summer.jpg` — результат преобразования `Photo1 -> лето`
* `Autumn.jpg` — результат преобразования `Photo2 -> осень`

Опционально (если `--save_masks`):

* `mask_autumn.png`, `alpha_autumn.png`
* `mask_summer.png`, `alpha_summer.png`

---

## 0) Чтение изображений

**Инструменты:**

* `cv2.imread(path, cv2.IMREAD_COLOR)` (OpenCV)

1. Считываем `Photo1.jpg` и `Photo2.jpg` в формате BGR (стандарт OpenCV).
2. Проверяем, что изображения прочитались (иначе кидаем ошибку).

Функция: `read_bgr(...)`.

---

## 1) Построение базовой маски по HSV

Это общая логика, которая используется в двух местах: для осенней листвы и для летней листвы.

**Инструменты:**

* `cv2.cvtColor(img, cv2.COLOR_BGR2HSV)` — перевод BGR -> HSV
* `cv2.split(hsv)` — разбиение на H,S,V
* логические операции `numpy` (маски вида `(H>=...) & (S>=...)`)

**Что делаем:**

1. Переводим изображение в HSV.
2. Для каждого пикселя проверяем попадание в диапазон:

   * `Hue` в диапазоне `[h1..h2]` (или wrap-around, если `h1 > h2`)
   * `Saturation >= s_min`
   * `Value >= v_min`
3. Получаем бинарную маску `{0,255}`.

Функция: `hsv_mask(img_bgr, MaskParams(...))`.

**Где вручную подбирались параметры:**

* Диапазоны `h1/h2`, `s_min`, `v_min` в `MaskParams(...)`
  Например:

  * летняя зелень: `h1=35, h2=95, s_min=60, v_min=55`
  * осенние тона: два диапазона `0..35` и `36..50` (чтобы покрыть желто-оранжевую и переходную зоны)

---

## 2) Удаление пикселей из маски

Чтобы не перекрашивать облака/небо, которые могут частично попадать в пороги по V/S, мы отдельно вычищаем такие области.

**Инструменты:**

* `cv2.cvtColor(..., cv2.COLOR_BGR2HSV)`
* `numpy` логика
* индексация массива маской: `mask[sky_like] = 0`


1. Считаем `sky_like = (S < 35) & (V > 170)` — это то ярко и почти без цвета.
2. Обнуляем эти пиксели в маске.

Функция: `remove_sky_like(mask, img_bgr)`.

**Где вручную подбирались параметры:**

* пороги `S < 35` и `V > 170` подбирались экспериментально, чтобы убрать облака, не затронув листву.

---

## 3) Морфологическая очистка маски (закрытие/открытие)

После порогов бывают:

* дырки внутри кроны,
* шумовые пиксели,
* разрывы.

**Инструменты:**

* `cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (k, k))`
* `cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)`
* `cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)`

**Что делаем:**

1. `CLOSE` — заполняет мелкие дырки.
2. `OPEN` — убирает мелкий шум.

Функция: `postprocess_mask(mask, k_close, k_open)`.

**Где вручную подбирались параметры:**

* размеры ядер `k_close`, `k_open`:

* для летней листвы: `k_close=9`, `k_open=7`
* для осенней листвы: `k_close=13`, `k_open=7`

---

## 4) Мягкая альфа (feather) — плавные границы

Чтобы переход между "измененным" и "исходным" был естественным, бинарная маска превращается в плавную альфу.

**Инструменты:**

* `cv2.GaussianBlur(mask, (blur, blur), 0)`
* нормализация: `/ 255.0`
* `numpy.clip` -> [0..1]

**Что делаем:**

1. Размываем бинарную маску гауссом.
2. Получаем `alpha ∈ [0..1]`.

Функция: `feather_mask(mask, blur)`.

**Где вручную подбирались параметры:**

* `blur=11` (лето->осень) — меньше размытие, меньше "подтекания" на стволы
* `blur=21` (осень->лето) — чуть мягче границы осенней кроны

---

# ВЕТКА A: `Photo1 (осень) -> Summer.jpg (лето)`

## A1) Маска осенней листвы на Photo1

**Инструменты:**

* `hsv_mask(...)`, `remove_sky_like(...)`, `postprocess_mask(...)`
* объединение масок: `cv2.bitwise_or(mask1, mask2)`
* `feather_mask(...)`

**Что делаем:**

1. Строим две теплые маски:

   * `warm1`: `H ∈ [0..35]` (оранжево-красные)
   * `warm2`: `H ∈ [36..50]` (желтоватые)
2. Объединяем `warm = warm1 OR warm2`.
3. Убираем sky_like.
4. Морфологически чистим (close/open).
5. Строим `autumn_alpha` через `feather_mask` и слегка усиливаем:

   * `alpha = clip(alpha * 1.3, 0..1)`.

Функция: `build_autumn_mask_on_photo1(autumn_bgr)`.

**Где вручную подбирались параметры:**

* диапазоны Hue `0..35` и `36..50`
* `k_close=13, k_open=7`
* `blur=21` и множитель `*1.3`

---

## A2) Перенос цвета "осени" в "лето" (Reinhard в Lab, только a/b)

Цель: сделать листву в Photo1 ближе к летней по цвету, но не менять освещение.

**Инструменты:**

* `cv2.cvtColor(..., cv2.COLOR_BGR2LAB)`
* `numpy.mean`, `numpy.std`
* векторная формула преобразования:

  
```text
x' = (x - mu_s) / sigma_s * sigma_r + mu_r
```
* применение только внутри маски через `np.where`

**Шаги**

1. Переводим `Photo1` и `Photo2` в Lab.
2. Внутри масок листвы считаем mean/std по каналам `a` и `b` отдельно для source и reference.
3. Преобразуем `a,b` в source к статистике reference.
4. Смешиваем с исходным значением по `strength` (регулирует силу эффекта).
5. Канал **L (яркость)** не меняем.

Функция: `reinhard_transfer_lab_ab_only(...)`.

**Где вручную подбирались параметры:**

* `--strength` по умолчанию 1.2 (вручную подбирался диапазон 0.8–1.4)

---

## A3) Смешивание результата по альфе

**Инструменты:**

* обычная формула alpha-blend в `numpy`

**Что делаем:**
```
out = base * (1 - alpha) + changed * alpha
```
Функция: `alpha_blend(autumn, autumn_changed, autumn_alpha)`.

Результат сохраняем в `Summer.jpg`.

---

# ВЕТКА B: `Photo2 (лето) -> Autumn.jpg (осень)`

## B1) Маска летней листвы на Photo2 + защита стволов + "добор" нижней кроны

Этот этап, чтобы:

* не перекрасить стволы,
* захватить нижние листья в тени.

**Инструменты:**

* `hsv_mask(...)`, `remove_sky_like(...)`, `postprocess_mask(...)`
* `cv2.dilate(...)` для расширения маски
* `numpy.where(...)` для фильтра extra_ok
* построение альфы `feather_mask(...)`

**Что делаем:**

1. `green0`: базовая зеленая маска (HSV + чистка).
2. `green_core`: "основа" маски (эрозия 1×1 — фактически без изменения, но оставлено как вручную подобранный параметр).
3. `green_extra`: расширенная маска через `dilate` (ядро 7×7).
4. Фильтруем `green_extra` условием:

   * `extra_ok = (S >= 80) & (V >= 45)`
     чтобы не лезть на стволы и все равно захватить темные листья.
5. Итоговая маска: `green = green_core OR green_extra`.
6. Строим альфу:

   * `alpha = feather_mask(green, blur=11)`
   * усиливаем: `alpha = clip(alpha * 1.8)`
7. Защита стволов/веток:

   * `trunk_like = (S < 80) | (V < 45)`
   * `alpha[trunk_like] = 0`.

Функция: `build_leaf_alpha_for_summer_to_autumn(summer_bgr)`.

**Где вручную подбирались параметры:**

* зеленый диапазон Hue: `35..95`, `s_min=60`, `v_min=55`
* `k_close=9`, `k_open=7`
* `dilate` ядро `(7,7)`
* `extra_ok: S>=80, V>=45`
* `blur=11`, множитель `*1.8`
* защита стволов `trunk_like: S<80 или V<45`

---

## B2) Перекраска листвы в осень (HSV)

**Инструменты:**

* `cv2.cvtColor(..., cv2.COLOR_BGR2HSV)`
* индексация `numpy` по маске `m`
* `np.clip`, обратный перевод `cv2.COLOR_HSV2BGR`

**Что делаем:**

1. Переводим летнее фото в HSV.
2. Внутри маски листвы принудительно ставим `Hue = hue_target`.
3. Усиливаем насыщенность и слегка затемняем:

   * `S *= sat_boost`
   * `V *= val_scale`

Функция: `hsv_autumn_recolor(...)`.

**Где вручную подбирались параметры:**

* `--hue_target` по умолчанию 18 (ручная настройка, типичный диапазон 15..25)
* `sat_boost = 1.65`
* `val_scale = 0.97`

---

## B3) Смешивание результата по альфе

**Инструменты:**

* alpha-blend в `numpy`

**Что делаем:**
```
Autumn = Photo2 * (1 - alpha) + recolored * alpha
```

Функция: `alpha_blend(summer, summer_orange, summer_alpha)`.

Сохраняем `Autumn.jpg`.

---

## 5) Режим отладки (`--save_masks`)

**Инструменты:**

* `cv2.imwrite(...)`

**Что сохраняем:**

* `mask_autumn.png` — маска осенней листвы на Photo1
* `alpha_autumn.png` — альфа осень->лето
* `mask_summer.png` — маска зеленой листвы на Photo2
* `alpha_summer.png` — альфа лето->осень

Это полезно, чтобы визуально проверить, где именно применяется перекраска и почему могут оставаться "зеленые" участки или артефакты.

---
## Достоинства и недостатки предложенного алгоритма

Ниже — оценка именно **на основе поведения алгоритма на данных фото** и тех артефактов, которые проявлялись во время настройки
---

### Достоинства

* **Простая реализация без нейросетей.**
  Все шаги основаны на классических методах обработки изображений:
HSV-пороговая сегментация, морфология, гауссово размытие маски, 
перенос статистики в Lab.

* **Плавные границы и отсутствие резких “вырезов”.**
  Вместо бинарного наложения используется альфа маска (`feather_mask`), поэтому переход по краю кроны естественный.

* **Лето -> осень управляется параметрами.**
  Осенний оттенок задается прямо параметром `hue_target` 
(оранжевый диапазон в шкале OpenCV), а также регулируются насыщенность 
* и яркость (`sat_boost`, `val_scale`).

* **Есть явная защита от подкраски стволов и веток.**
  На ранних версиях появлялся артефакт “стволы светятся/подкрашиваются”.
Он уменьшился за счет обнуления альфы на пикселях стволов: `trunk_like = (S < threshold) | (V < threshold)`.

* **Удобная отладка (`--save_masks`).**
  Сохранение `mask_*.png` и `alpha_*.png` позволяет визуально 
проверить, что именно перекрашивается, и аргументированно 
объяснить в отчете, почему менялись пороги.

---

### Недостатки / ограничения

* **Зависимость от ручных порогов и параметров (под конкретные фото).**
  Чтобы убрать артефакты на данных изображениях, параметры подбирались вручную:

  * пороги HSV для листвы,
  * размеры `k_close`, `k_open`,
  * параметры сглаживания маски (`blur`),
  * пороги `extra_ok` (для теневых листьев),
  * пороги `trunk_like` (для защиты стволов),
  * коэффициенты усиления альфы (`*1.8`) и т.д.
    На других сценах с другим освещением числа могут потребовать 
  перенастройки.

* **Пороговая сегментация не понимает ничего, кроме оттенка.**
  Если в кадре есть объекты похожих цветов (зеленая трава, кусты, одежда, машина), они могут попасть в маску и измениться вместе с листвой. 
На текущих фото это не критично, 
но метод в принципе не гарантирует идеального отделения “дерево/не дерево”.

* **Сложно идеально отделить листву от тонких веток.**
  Даже с `trunk_like` на тонких ветках возможны 
остаточные эффекты (слегка измененный оттенок рядом со стволом). 
Это типичная проблема методов на основе цвета и мягкого смешивания.

* **Осенний цвет моделируется упрощенно.**
Перекраска через фиксированный `hue_target` делает осень более однородной. (Можно усложнить, но это уже другой уровень алгоритма.)

* **Два направления решаются разными методами.**
  Осень->Лето делается переносом статистики (Reinhard), а Лето->Осень — перекраской hue. Это практично и дает хороший визуальный результат, но математически метод не симметричен: качество и характер артефактов могут отличаться в двух направлениях.

---
