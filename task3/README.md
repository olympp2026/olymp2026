
# Задание 3 — деобезличивание набора данных (телефоны + email + адрес)

---

## Идея задачи и как определили алгоритмы обезличивания

В исходном файле `Задание-3-данные.xlsx` три поля:
- `Телефон` — хранится в виде **хэша SHA1**
- `email` — зашифрован подстановкой (сдвигом)
- `Адрес` — зашифрован подстановкой (сдвигом)

### 1) Телефон: SHA1
По формату значений в колонке `Телефон` (строка из 40 hex-символов) было определено, что это **SHA1**:
- длина 40 символов = 160 бит
- алфавит `0-9a-f`

**Алгоритм обезличивания:** криптографический хэш SHA1 (односторонняя функция).

### 2) Email и адрес: шифр Цезаря (сдвиг)
В колонке `Адрес` есть повторяющийся фрагмент вида `??.<число>`, который соответствует `кв.<число>` (квартира). (то есть ясно, что две буквы с точкой и 3 цифры - это номер квартиры) 

Это позволило:
- выделить шаблон `([А-Яа-я]{2})\.(\d+)`
- взять **последнее** такое совпадение в адресе (обычно это именно `кв.`)
- по двум буквам определить величину сдвига относительно эталона `к` и `в`

Если обе буквы дают один и тот же сдвиг — значит это **равномерный сдвиг по алфавиту**, т.е. классический **шифр Цезаря**.

**Алгоритм обезличивания:** шифр Цезаря  
**Ключ:** величина сдвига `key` (целое число), одинаковая для email и адреса в строке.
 Для email это проверялось опытным путем
---

## Реализованное решение

Решение состоит из двух этапов:

1) `attack_hashcat.py`  
   Восстановление телефонов из SHA1-хэшей с помощью hashcat (масочная атака по формату **8 + 10 цифр**).
 Были проведены атаки 10 цифр, 8 + 10 цифр и сработала последняя
2) `decipher.py`  
   Дешифрование email и адреса через найденный ключ `key` (шифр Цезаря) + сбор финального датасета в Excel.

На выходе получается файл:
- `deanonymized_correct.xlsx` — полностью расшифрованные поля `Телефон`, `email`, `Адрес` и ключ `key`.

---

## Требования


- требуются зависимости:
```bash
pip install pandas openpyxl
````

### Hashcat

* hashcat 7.1.2 (лежит локально в проекте):

```
hashcat-7.1.2/hashcat.exe
hashcat-7.1.2/OpenCL/...
```

> Важно: hashcat должен запускаться с рабочей директорией `hashcat-7.1.2`, иначе он не найдёт `./OpenCL/`.

---

## Структура проекта (пример)

```
task3/
  attack_hashcat.py
  decipher.py
  Задание-3-данные.xlsx
  hashcat-7.1.2/
    hashcat.exe
    OpenCL/
    kernels/
    ...
  out/
    hashes_phone.txt
    hashcat_phone_out.txt
    phones.potfile
    decrypted_telephone_numbers.txt
    phones_recovered.xlsx
```

---

## Этап 1 — Взлом телефонов (attack_hashcat.py)

маска для hashcat:

```
8?d?d?d?d?d?d?d?d?d?d
```

SHA1 — односторонняя функция, обратного преобразования нет.
Единственный практический способ — перебор кандидатов и сравнение их SHA1 с хэшем.

### Тип атаки

Используется **mask attack** (`-a 3`) — перебор по маске.

* `-m 100` — режим SHA1
* `-a 3` — масочная атака
* маска: `8` + `10` цифр

### Особенности запуска на “старом” компьютере (Intel OpenCL)

Компьютер использует Intel OpenCL и старый драйвер. В таком окружении:

* GPU (Intel HD Graphics 4400) часто “видится” (`hashcat -I`), но может быть пропущена или нестабильна
* CPU-устройство работает надёжнее

Поэтому запуск производится на CPU:

* `-D 1` — выбрать CPU
* `-d 2` — Device #02 (CPU из вывода `hashcat -I`)

Также для стабильности и снижения нагрузки используются:

* `--force` — игнорировать “опасные” предупреждения драйверов (используется именно из-за проблем Intel OpenCL)
* `-O` — optimized kernel (ускоряет перебор)
* `-w 1` — минимальный workload (меньше нагрузка/память, выше стабильность на слабом железе)
* `--kernel-accel 38` и `--kernel-loops 512` — параметры, подобранные под устройство, чтобы hashcat работал стабильно и не падал

### Почему иногда hashcat ничего не считает и пишет про potfile

Если hashcat уже когда-то взломал эти хэши, он может вывести:
`All hashes found as potfile ... Use --show`

Это означает, что результаты уже лежат в potfile и повторный перебор не требуется.
В коде это учтено: используется локальный potfile `out/phones.potfile` + выгрузка результатов через `--show`.

### Что создаёт скрипт

После запуска `attack_hashcat.py` формируются файлы в `out/`:

* `hashes_phone.txt` — список SHA1-хэшей телефонов (вход для hashcat)
* `hashcat_phone_out.txt` — найденные пары `hash:phone` (или список телефонов, если используется вывод `--show`)
* `decrypted_telephone_numbers.txt` — итоговый список телефонов (plain), который используется на следующем этапе
* `phones_recovered.xlsx` — контрольный файл (для проверки)

---

## Этап 2 — Дешифрование email и адреса + сбор результата (decipher.py)

### Как извлекается ключ `key`

Из поля `Адрес` берётся последняя подстрока вида:

```
??.<число>
```

которая соответствует `кв.<число>` (квартира).

Берём две буквы перед точкой и считаем сдвиг:

* первая буква относительно `к`
* вторая буква относительно `в`

Если оба сдвига совпали — получаем `key`.

### Как расшифровывается текст

Шифр Цезаря реализован как циклический сдвиг:

* для русских букв используется алфавит без `ё` (получено опытным путем, что ё не нужна)
* для латиницы используется алфавит `a-z` / `A-Z`
* остальные символы (цифры, `@`, `.`, пробелы, `-`, `,` и т.д.) не меняются

Расшифрование = сдвиг на `-key`.

### Отсюда берем телефоны:

`decipher.py` читает файл:

```
out/decrypted_telephone_numbers.txt
```

и использует телефоны **в том же порядке**, что строки исходной таблицы.

### Результат

Файл:

* `deanonymized_correct.xlsx`

Столбцы:

* `Телефон` (расшифрованный)
* `email` (расшифрованный)
* `Адрес` (расшифрованный)
* `key` (ключ сдвига)

---

## Как запустить решение (пошагово)

### 1) Восстановить телефоны

Из папки проекта:

```bat
cd /d C:\Users\annam\olymp\task3
python attack_hashcat.py
```

Проверка результата:

* `out/decrypted_telephone_numbers.txt` должен содержать список телефонов
* `out/phones_recovered.xlsx` можно открыть для контроля

### 2) Расшифровать email и адрес, собрать финальный Excel

```bat
cd /d C:\Users\annam\olymp\task3
python decipher.py
```

На выходе:

* `deanonymized_correct.xlsx`

---
